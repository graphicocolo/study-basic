# JavaScript ES6（ES2015） ブロックスコープ

`{}` で囲まれた範囲のことです。その中で宣言した変数は、外からアクセスできません。

```js
{
  const message = "ブロックの中";
  console.log(message); // ✅ "ブロックの中"
}
console.log(message); // ❌ エラー！ 外からは見えない
```

---

1. let / const はブロックスコープ、var は違う

これが最も重要なポイントです。

```js
if (true) {
  var a = "var で宣言";
  let b = "let で宣言";
  const c = "const で宣言";
}

console.log(a); // ✅ "var で宣言"   ← ブロックを無視して外から見える！
console.log(b); // ❌ エラー
console.log(c); // ❌ エラー
```

|    |  スコープ  |  挙動  |
| ---- | ---- | ---- |
|  var  |  関数スコープ  |  {} を無視して外に漏れる  |
|  let / const  |  ブロックスコープ  |  {} の中に閉じ込められる  |

だから現代の JavaScript では var を避けて let / const を使います。

---

2. for ループでの違い（実務でよくハマる）

```js
// var → 全部 3 になる（変数が共有されてしまう）
for (var i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(i);
  }, 1000);
}
// 出力: 3, 3, 3

// let → 期待通りになる（ループごとに別の変数が作られる）
for (let i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(i);
  }, 1000);
}
// 出力: 0, 1, 2
```

---

3. どこがブロックになるか

`{}` があれば全部ブロックスコープを作ります。

```js
// if文
if (true) {
  const x = 1;
}

// for文
for (let i = 0; i < 5; i++) {
  const y = i;
}

// ただの {}（意味のあるブロック）
{
  const temp = "一時的な変数";
  // ここだけで使いたい処理
}

// 関数の {}（これは関数スコープでもありブロックスコープでもある）
function example() {
  const z = 2;
}
```

---

4. ブロックスコープは入れ子になる

内側から外側は見えるが、外側から内側は見えません。

```js
const outer = "外側";

{
  const inner = "内側";
  console.log(outer); // ✅ 外側の変数は見える
  console.log(inner);
}

console.log(outer);
console.log(inner); // ❌ 内側の変数は見えない
```

---

まとめ

|  学ぶべきポイント  |  一言で  |
| ---- | ---- |
|  let/const はブロックスコープ  |  {} の中に閉じる  |
|  var は関数スコープ  |  {} を無視して漏れる → 使わない  |
|  for ループでの挙動の差  |  var は共有、let は各回ごとに独立  |
|  {} がブロックを作る  |  if, for, 単独の {} すべて  |
|  入れ子のルール  |  内→外は見える、外→内は見えない  |

---

## `var` の for ループで 3 が 3 回表示される理由（時系列トレース）

このコードには「今すぐ動く部分」と「後で動く部分」がある

```js
for (var i = 0; i < 3; i++) {    // ← 今すぐ動く
  setTimeout(function () {        // ← 今すぐ動く（予約だけ）
    console.log(i);               // ← 1秒後に動く
  }, 1000);
}
```

### 【今すぐ実行される部分】（一瞬で終わる）

```
時刻 0ms ごろ：ループ開始
─────────────────────────────────────────────
1周目: i = 0
  → i < 3 ? → 0 < 3 → true → ループに入る
  → setTimeout で「1秒後に console.log(i) してね」と予約する
    ※ この時点では console.log は実行されない。予約だけ。
  → i++ → i は 1 になる

2周目: i = 1
  → i < 3 ? → 1 < 3 → true → ループに入る
  → setTimeout で「1秒後に console.log(i) してね」と予約する
  → i++ → i は 2 になる

3周目: i = 2
  → i < 3 ? → 2 < 3 → true → ループに入る
  → setTimeout で「1秒後に console.log(i) してね」と予約する
  → i++ → i は 3 になる

4周目（ループ終了判定）:
  → i < 3 ? → 3 < 3 → false → ループ終了 🛑
─────────────────────────────────────────────
ループ完了。この時点で i = 3。
予約が3つ溜まっている。
```

### 【1秒後に実行される部分】

```
時刻 1000ms ごろ：予約された3つの関数が動き出す
─────────────────────────────────────────────
予約1: console.log(i) → i は今いくつ？ → 3 → "3" と表示
予約2: console.log(i) → i は今いくつ？ → 3 → "3" と表示
予約3: console.log(i) → i は今いくつ？ → 3 → "3" と表示
```

### なぜこうなるのか

`var i` は1つしか存在しない。

```
メモリのイメージ：

┌──────────────────┐
│  変数 i （1個）    │  ← var なので、全体で1つだけ
│  現在の値: 3      │
└──────────────────┘
        ↑       ↑       ↑
      予約1    予約2    予約3
    「i を見ろ」「i を見ろ」「i を見ろ」
```

3つの予約は「i の値をコピーして持っている」のではなく、「i を見に行け」という指示を持っているだけ。

1秒後に見に行ったら、ループはとっくに終わっていて、i は 3 になっている。だから全部 3 になる。

### `let` にするとなぜ直るのか

```js
for (let i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(i);
  }, 1000);
}
```

```
メモリのイメージ：

┌──────────┐  ┌──────────┐  ┌──────────┐
│ i（1周目）│  │ i（2周目）│  │ i（3周目）│  ← let はループごとに別の変数
│  値: 0   │  │  値: 1   │  │  値: 2   │
└──────────┘  └──────────┘  └──────────┘
      ↑              ↑              ↑
    予約1           予約2           予約3
```

let はループ1周ごとに別の変数が作られるので、それぞれの予約が自分専用の i を見に行く。だから 0, 1, 2 と表示される。

1. setTimeout の中身が動く頃には、ループはとっくに終わっている
2. 見に行く変数が var なら1つ、let ならループごとに別物

これは、関数スコープでもなくブロックスコープでもない、forに固有の話

let がループ1周ごとに新しい変数を作る、というのは for 文の仕様で特別に決められた挙動 です。

for (let i = ...) と書いたときだけ、JavaScript エンジンが各反復ごとに i のコピーを作るという特別な処理をしてくれます。これは ECMAScript
の仕様（https://tc39.es/ecma262/#sec-createperiterationenvironment）で明示的に定められている for 固有のルールです。
